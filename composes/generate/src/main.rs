use std::env;
use std::fs::File;
use std::io::prelude::*;

const START: &str = r#"
# this file is auto generated by generate.py
# do not edit it manually

version: '3.9'
services:
"#;

const END: &str = r#"
networks:
  intrnl:
    ipam:
      driver: default
      config:
        - subnet: "192.168.92.0/24"

# This Docker Compose file defines a multi-container application with four services: 
# app0, app1, app2, and app3. The file specifies how the services should be built, 
# configured, and run.

# This app0 ... app3 are the nodes of the blockchain network. Each node is a container
# running a blockchain node. The nodes are connected to each other via a TCP protocol.

# This specifies that the app0...3 service should be built using the Dockerfile located
# in the composes directory, with the node argument set to node0...3. The service should
# also expose port 3333..3336 on the host and map it to port 3333..3336 on the container.
# The command field specifies the command that should be run when the container is started,
# which in this case is ./executor 0..3. The networks field specifies that the service
# should be connected to the internal network and should be assigned the IP address 192.168.92.21...24.
"#;

const LOOP_BODY: &str = r#"
  app#i:
    build:
      context: ..
      dockerfile: ./docker/compose.Dockerfile
      args:
        node: node#i
        port: #port
    ports:
      - '#port:#port'
    command: ./executor #i --ci-mode
    environment:
      - 'RUST_LOG=DEBUG'
    networks:
      intrnl:
        ipv4_address: '#ip'
    volumes:
      - ../logs/node#i:/usr/src/myapp/artifacts/node#i/logs
"#;

fn get_ip_by_i(index: usize) -> String {
    format!("192.168.92.{}", index + 21)
}

fn get_port_by_i(index: usize) -> String {
    format!("{}", index + 3333)
}

fn get_loop_body(size: usize) -> String {
    let mut body = String::new();
    for i in 0..size {
        body += &LOOP_BODY
            .replace("#ip", &get_ip_by_i(i))
            .replace("#port", &get_port_by_i(i))
            .replace("#i", &i.to_string());
    }
    body
}

fn get_compose_file(size: usize) -> String {
    format!("{}{}{}", START, get_loop_body(size), END)
}

fn sizes() -> Vec<usize> {
    let small: Vec<usize> = (1..4).map(|i| 3 * i + 1).collect();
    let big: Vec<usize> = (1..4).map(|i| 3 * 5 * i + 1).collect();
    let possible: Vec<usize> = (1..334).map(|i| 3 * i + 1).collect();
    let pow2: Vec<usize> = (1..7)
        .filter_map(|i| {
            let num = 2usize.pow(i as u32);
            if possible.contains(&num) {
                Some(num)
            } else {
                None
            }
        })
        .collect();

    let mut sizes: Vec<usize> = small;
    sizes.extend(big);
    sizes.extend(pow2);
    sizes.sort();

    sizes
}

fn save_compose_file(size: usize) {
    let file_path = format!("../../composes/docker-compose.local{}.yml", size);
    let mut file = File::create(&file_path).expect("Failed to create file");
    let compose_file = get_compose_file(size);
    file.write_all(compose_file.as_bytes())
        .expect("Failed to write to file");
    println!("saved {}", file_path);
}

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        println!("usage: cargo run <size>");
        std::process::exit(1);
    }

    let what_to_do = &args[1];

    if what_to_do == "all" {
        for i in sizes() {
            save_compose_file(i);
        }
        std::process::exit(0);
    }

    let size = match args[1].parse::<usize>() {
        Ok(value) => value,
        Err(_) => {
            println!("Invalid size argument");
            std::process::exit(1);
        }
    };

    let supported_sizes = (1..=67).step_by(3).collect::<Vec<usize>>();

    if !supported_sizes.contains(&size) {
        println!("size {} is not supported", size);
        std::process::exit(1);
    }

    save_compose_file(size);
    std::process::exit(0);
}
