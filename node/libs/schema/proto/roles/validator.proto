syntax = "proto3";

package roles.validator;

import "std.proto";

message BlockHash {
  optional bytes sha256 = 1;
}

message Block {
  optional BlockHash parent = 1;
  optional uint64 number = 2;
  optional bytes payload = 3;
}

message FinalBlock {
  optional Block block = 1;
  optional CommitQC justification = 2;
}

message ConsensusMsg {
  oneof t {
    ReplicaPrepare replica_prepare = 1;
    ReplicaCommit replica_commit = 2;
    LeaderPrepare leader_prepare = 3;
    LeaderCommit leader_commit = 4;
  }
}

message ReplicaPrepare {
  optional uint64 view = 1;
  optional ReplicaCommit high_vote = 2;
  optional CommitQC high_qc = 3;
}

message ReplicaCommit {
  optional uint64 view = 1;
  optional BlockHash hash = 2;
  optional uint64 number = 3;
}

message LeaderPrepare {
  optional Proposal proposal = 1;
  optional PrepareQC justification = 2;
}

message Proposal {
  oneof t {
    Block new = 1;
    ReplicaCommit retry = 2;
  }
}

message LeaderCommit {
  optional CommitQC justification = 1;
}

message PrepareQC {
  repeated ReplicaPrepare msgs = 1;
  repeated bytes signers = 2;
  optional AggregateSignature sig = 3;
}

message CommitQC {
  optional ReplicaCommit msg = 1;
  optional bytes signers = 2;
  optional AggregateSignature sig = 3;
}

message Phase {
  oneof t {
    std.Void prepare = 1;
    std.Void commit = 2;
  }
}

// A message broadcasted by a validator
// over the gossip network announcing
// its own TCP address. Other validators
// are expected to establish a consensus
// network connection to this address.
message NetAddress {
  // Address of the validator.
  optional std.SocketAddr addr = 1;
  // Version of the discovery announcement.
  // Newer (higher) version overrides the older version.
  // When a validator gets restarted it broadcasts
  // its discovery message with version = 0. If it learns
  // from the network a newer version of its own discovery message
  // it immediately broadcasts another one to override the received one
  // (it may happen, since it broadcasted its discovery message also during
  // the previous execution).
  //
  // Currently the IP of the validator is static, but this scheme might also
  // be used to provide dynamic IP support (if validator discovers that its
  // own IP has changed - by pinging a trusted STUN server for example - it can
  // broadcast a new discovery message), or (mutli)proxy support (a validator
  // may maintain a dynamic set of trusted proxy servers which forward traffic
  // to it - this way validator wouldn't have to have a public IP at all).
  optional uint64 version = 2;
  // Time at which this message has been signed.
  // Mostly an informational field:
  // we cannot use it instead of version field,
  // because the walltime clock is not guaranteed to be monotone.
  // We use it as a version "tie breaker" though:
  // we compare (version,timestamp) lexicographically to
  // decide which discovery message is newer.
  // It is useful in the following scenario:
  // 1. validator broadcasts discovery message with (version1,timestamp1)
  // 2. validator gets restarted and forgets what it has broadcasted.
  // 3. validator broadcasts discovery message with (version1,timestamp2)
  // 4. as long as timestamp1 != timestamp2, one of the messages will be considered
  //    newer and eventually all nodes will learn this message. It wouldn't be the
  //    case if both messages had exactly the same version - nodes would keep
  //    the first message that arrived and decline to broadcast the other.
  //
  // Note that although we DO NOT assume timestamps to be monotone,
  // we assume here that it is unlikely for timestamps to collide.
  // To make this reasoning more strict, we should rather use a random "tie breaker"
  // instead (replace timestamp with a random nonce, or use a hash of the entire message).
  optional std.Timestamp timestamp = 3;
}

message Msg {
  oneof t {
    ConsensusMsg consensus = 1;
    bytes session_id = 2;
    NetAddress net_address = 3;
  }
}

message MsgHash {
  optional bytes sha256 = 1;
}

message Signed {
  optional Msg msg = 1;
  optional PublicKey key = 2;
  optional Signature sig = 3;
}

message PublicKey {
  optional bytes bls12381 = 1;
}

message Signature {
  optional bytes bls12381 = 1;
}

message AggregateSignature {
  optional bytes bls12381 = 1;
}
