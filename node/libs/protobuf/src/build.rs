//! Build-related functionality. This should only be used by the code generated by the `protobuf_build` crate.

pub use once_cell::sync::Lazy;
pub use prost;
use prost::Message as _;
pub use prost_reflect;
use prost_reflect::prost_types;
use std::sync::RwLock;

/// Global descriptor pool.
static POOL: Lazy<RwLock<prost_reflect::DescriptorPool>> = Lazy::new(RwLock::default);

/// Protobuf descriptor + info about the mapping to rust code.
#[derive(Debug)]
pub struct Descriptor(());

impl Descriptor {
    /// Constructs a descriptor and adds it to the global pool.
    pub fn new(_dependencies: &[&'static Self], descriptor_bytes: &[u8]) -> Self {
        let descriptor = prost_types::FileDescriptorSet::decode(descriptor_bytes).unwrap();
        let pool = &mut POOL.write().unwrap();

        // Dependencies are already loaded to the global pool on their initialization.
        // The fact that we have their refs is sufficient to prove that they are already in the global pool.
        Self::load(pool, descriptor).expect("failed loading descriptor into global pool");
        Self(())
    }

    /// Loads the descriptor to the pool, if not already loaded.
    fn load(
        pool: &mut prost_reflect::DescriptorPool,
        descriptor: prost_types::FileDescriptorSet,
    ) -> anyhow::Result<()> {
        let pool_has_all_files = descriptor
            .file
            .iter()
            .all(|file| pool.get_file_by_name(file.name()).is_some());
        if pool_has_all_files {
            return Ok(());
        }
        pool.add_file_descriptor_set(descriptor)?;
        Ok(())
    }

    /// Returns a descriptor by a fully qualified message name.
    pub fn get_message_by_name(&self, name: &str) -> Option<prost_reflect::MessageDescriptor> {
        POOL.read().unwrap().get_message_by_name(name)
        // ^ This works because this descriptor must have been loaded into the global pool
        // when the instance was constructed.
    }
}

/// Expands to a descriptor declaration.
#[macro_export]
macro_rules! declare_descriptor {
    ($name:ident => $descriptor_path:expr, $($rust_deps:path),*) => {
        pub static $name: $crate::build::Lazy<$crate::build::Descriptor> =
            $crate::build::Lazy::new(|| {
                $crate::build::Descriptor::new(
                    &[$({ use $rust_deps as dep; &dep::DESCRIPTOR }),*],
                    ::std::include_bytes!($descriptor_path),
                )
            });
    }
}

/// Implements `ReflectMessage` for a type based on a provided `Descriptor`.
#[macro_export]
macro_rules! impl_reflect_message {
    ($ty:ty, $descriptor:expr, $proto_name:expr) => {
        impl $crate::build::prost_reflect::ReflectMessage for $ty {
            fn descriptor(&self) -> $crate::build::prost_reflect::MessageDescriptor {
                static INIT: $crate::build::Lazy<$crate::build::prost_reflect::MessageDescriptor> =
                    $crate::build::Lazy::new(|| {
                        $crate::build::Descriptor::get_message_by_name($descriptor, $proto_name)
                            .unwrap()
                    });
                INIT.clone()
            }
        }
    };
}

pub use declare_descriptor;
pub use impl_reflect_message;
