//! Build-related functionality. This should only be used by the code generated by the `protobuf_build` crate.

pub use once_cell::sync::Lazy;
pub use prost;
use prost::Message as _;
pub use prost_reflect;
use prost_reflect::prost_types;
use std::sync::RwLock;

/// Global descriptor pool.
static POOL: Lazy<RwLock<prost_reflect::DescriptorPool>> = Lazy::new(RwLock::default);

/// Protobuf descriptor + info about the mapping to rust code.
#[derive(Debug)]
pub struct Descriptor {
    /// Raw descriptor proto.
    descriptor_proto: prost_types::FileDescriptorSet,
    /// Direct dependencies of this descriptor.
    dependencies: Vec<&'static Self>,
}

impl Descriptor {
    /// Constructs a descriptor and adds it to the global pool.
    pub fn new(dependencies: Vec<&'static Descriptor>, descriptor_bytes: &[u8]) -> Self {
        let this = Descriptor {
            dependencies,
            descriptor_proto: prost_types::FileDescriptorSet::decode(descriptor_bytes).unwrap(),
        };
        let pool = &mut POOL.write().unwrap();
        this.load(pool)
            .expect("failed loading descriptor into global pool");
        this
    }

    /// Loads the descriptor to the pool, if not already loaded.
    fn load(&self, pool: &mut prost_reflect::DescriptorPool) -> anyhow::Result<()> {
        if self
            .descriptor_proto
            .file
            .iter()
            .all(|f| pool.get_file_by_name(f.name()).is_some())
        {
            return Ok(());
        }
        for dependency in &self.dependencies {
            dependency.load(pool)?;
        }
        pool.add_file_descriptor_set(self.descriptor_proto.clone())?;
        Ok(())
    }

    /// Loads the descriptor to the global pool and returns a copy of the global pool.
    pub fn get_message_by_name(&self, name: &str) -> Option<prost_reflect::MessageDescriptor> {
        POOL.read().unwrap().get_message_by_name(name)
        // ^ This works because this descriptor must have been loaded into the global pool
        // when the instance was constructed.
    }
}

/// Expands to a descriptor declaration.
#[macro_export]
macro_rules! declare_descriptor {
    ($name:ident => $descriptor_path:expr, $($rust_deps:path),*) => {
        pub static $name: $crate::build::Lazy<$crate::build::Descriptor> =
            $crate::build::Lazy::new(|| {
                $crate::build::Descriptor::new(
                    ::std::vec![$({ use $rust_deps as dep; &dep::DESCRIPTOR }),*],
                    ::std::include_bytes!($descriptor_path),
                )
            });
    }
}

/// Implements `ReflectMessage` for a type based on a provided `Descriptor`.
#[macro_export]
macro_rules! impl_reflect_message {
    ($ty:ty, $descriptor:expr, $proto_name:expr) => {
        impl $crate::build::prost_reflect::ReflectMessage for $ty {
            fn descriptor(&self) -> $crate::build::prost_reflect::MessageDescriptor {
                static INIT: $crate::build::Lazy<$crate::build::prost_reflect::MessageDescriptor> =
                    $crate::build::Lazy::new(|| {
                        $crate::build::Descriptor::get_message_by_name($descriptor, $proto_name)
                            .unwrap()
                    });
                INIT.clone()
            }
        }
    };
}

pub use declare_descriptor;
pub use impl_reflect_message;
