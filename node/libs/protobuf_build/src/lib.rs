//! Generates rust code from the proto files.
//!
//! Basic concepts:
//! * input path - absolute path of the proto file as visible in the file system. Example:
//!     $CARGO_MANIFEST_DIR/<input_root>/some/location/abc.proto
//! * output path - absolute path of the output files (generated by this library) as visible in the
//!     file system. Output paths are derived from the input paths to keeps things clear. Example:
//!     $OUT_DIR/<input_root>/generated_file
//! * proto path - absolute path of the proto file used for importing other proto files.
//!     These are derived from <proto_package> field in the config and the input path. Example:
//!     <proto_root>/some/location/abc.proto
//! * proto package - in addition to the space of input paths and the space of proto paths, there is also
//!     a space of proto packages which is used to reference message types from different proto
//!     files. Theoretically it can be totally independent from the proto paths (i.e. you can have
//!     "my.favorite.package" proto package defined in "totally/unrelated/file/name.proto", but we
//!     recommend the following naming convention: proto package "a.b.c" should be defined either:
//!     a) in a single file "a/b/c.proto", or
//!     b) in a collection of files under "a/b/c/" directory
//!     Option b) is useful for defining large packages, because there is no equivalent of "pub use" in proto syntax.
//! * rust path - a rust module path that the generated code is available at TODO
//!
//! Protobuf files are collected recursively from $CARGO_MANIFEST_DIR/<input_path>/ directory.
//! Corresponding "cargo:rerun-if-changed=..." line is printed to stdout, so that
//! the build script running this function is rerun whenever proto files change.
//! A single rust file is generated and stored at $OUT_DIR/<input_path>/gen.rs file.
//!
//! Protobuf files are compiled to a protobuf descriptor stored at
//! $OUT_DIR/<input_path>/gen.binpb.
//! Additionally a "PROTOBUF_DESCRIPTOR=<absolute path to that descriptor>" line is printed to
//! stdout. This can be used to collect all the descriptors across the build as follows:
//! 1. Checkout the repo to a fresh directory and then run "cargo build --all-targets"
//!    We need it fresh so that every crate containing protobufs has only one build in the
//!    cargo cache.
//! 2. grep through all target/debug/build/*/output files to find all "PROTOBUF_DESCRIPTOR=..."
//!    lines and merge the descriptor files by simply concatenating them.
//! Note that you can run this procedure for 2 revisions of the repo and look for breaking
//! changes by running "buf breaking <after.binpb> --against <before.binpb>" where before.binpb
//! and after.binpb are the concatenated descriptors from those 2 revisions.
//!
//! The proto files are not expected to be self-contained - to import proto files from
//! different crates you need to specify them as dependencies in the Config.dependencies.
//! It is not possible to depend on a different proto bundle within the same crate (because
//! these are being built simultaneously from the same build script).
//!
//! cargo build --all-targets
//! perl -ne 'print "$1\n" if /PROTOBUF_DESCRIPTOR="(.*)"/' `find target/debug/build/*/output -type f` | xargs cat > /tmp/sum.binpb
//! buf breaking /tmp/sum.binpb --against /tmp/sum.binpb
use anyhow::Context as _;
use std::{collections::BTreeMap, fs, path::{PathBuf,Path}};
use prost::Message as _;
use std::collections::HashSet;
use std::sync::Mutex;

// Imports accessed from the generated code.
pub use prost;
pub use prost_reflect;
pub use once_cell::sync::Lazy;

mod ident;
mod canonical;
pub mod rust;

/// Traversed all the files in a directory recursively.
fn traverse_files(path: &Path, f: &mut impl FnMut(&Path) -> anyhow::Result<()>) -> anyhow::Result<()> {
    if !path.is_dir() {
        f(path).with_context(||path.to_str().unwrap().to_string())?;
        return Ok(());
    }
    for entry in fs::read_dir(path)? {
        traverse_files(&entry?.path(), f)?;
    }
    Ok(())
}

/// Protobuf descriptor + info about the mapping to rust code.
pub struct Descriptor {
    proto_package: ProtoPackage,
    descriptor_proto: prost_types::FileDescriptorSet,
    dependencies: Vec<&'static Descriptor>,
}

impl Descriptor {
    /// Constructs a Descriptor.
    pub fn new(proto_package: ProtoPackage, dependencies: Vec<&'static Descriptor>, descriptor_bytes: &impl AsRef<[u8]>) -> Self {
        Descriptor {
            proto_package,
            dependencies,
            descriptor_proto: prost_types::FileDescriptorSet::decode(descriptor_bytes.as_ref()).unwrap(),
        }
    }

    /// Loads the descriptor to the pool, if not already loaded.
    pub fn load(&self, pool: &mut prost_reflect::DescriptorPool) -> anyhow::Result<()> {
        if self.descriptor_proto.file.iter().all(|f| pool.get_file_by_name(f.name()).is_some()) {
            return Ok(());
        }
        for d in &self.dependencies {
            d.load(pool)?;
        }
        pool.add_file_descriptor_set(self.descriptor_proto.clone())?;
        Ok(())
    }

    /// Loads the descriptor to the global pool and returns a copy of the global pool.
    pub fn load_global(&self) -> prost_reflect::DescriptorPool {
        static POOL : Lazy<Mutex<prost_reflect::DescriptorPool>> = Lazy::new(||Mutex::default());
        let pool = &mut POOL.lock().unwrap();
        self.load(pool).unwrap();
        pool.clone()
    }
}

/// Path relative to $CARGO_MANIFEST_DIR
#[derive(Clone,PartialEq,Eq)]
pub struct InputPath(PathBuf);

impl From<&str> for InputPath {
    fn from(s:&str) -> Self { Self(PathBuf::from(s)) }
}

impl InputPath {
    fn abs(&self) -> PathBuf {
        PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap())
            .canonicalize().unwrap().join(&self.0)
    }

    /// Path relative to $OUT_DIR with the given extenstion
    fn prepare_output_dir(&self) -> PathBuf {
        let output = PathBuf::from(std::env::var("OUT_DIR").unwrap())
            .canonicalize().unwrap().join(&self.0);
        let _ = fs::remove_dir_all(&output);
        fs::create_dir_all(&output).unwrap();
        output
    }
}

/// Represents a (relative) proto package path.
#[derive(Clone,PartialEq,Eq)]
pub struct ProtoPackage(Vec<String>);

impl ProtoPackage {
    /// Checks if package path starts with the given prefix.
    fn starts_with(&self, prefix: &Self) -> bool {
        let n = prefix.0.len();
        self.0.len() >= n && self.0[0..n] == prefix.0
    }

    fn strip_prefix(&self, prefix: &Self) -> anyhow::Result<Self> {
        if !self.starts_with(prefix) {
            anyhow::bail!("{} is not a prefix of {}",prefix.to_string(),self.to_string());
        }
        Ok(Self(self.0[prefix.0.len()..].iter().cloned().collect()))
    }

    fn to_rust_module(&self) -> rust::Name {
        RustName(self.0.iter().map(|s|ident::to_snake(s)).collect())
    }

    fn to_rust_type(&self) -> rust::Name {
        let n = self.0.len();
        let mut res = self.to_rust_module();
        res.0[n-1] = ident::to_upper_camel(&self.0[n-1]);
        res
    }

    fn to_string(&self) -> String {
        self.0.join(".")
    }
}

impl From<&str> for ProtoPackage {
    fn from(s:&str) -> Self {
        Self(s.split(".").map(String::from).collect())
    }
}

impl From<&Path> for ProtoPackage {
    fn from(p:&Path) -> Self {
        Self(p.iter().map(|c|c.to_str().unwrap().to_string()).collect())
    }
}

pub struct Config {
    /// Input directory relative to $CARGO_MANIFEST_DIR with the proto files to be compiled.
    pub input_path: InputPath,
    /// Implicit prefix that should be prepended to proto paths of the proto files in the input directory.
    pub proto_path: PathBuf,
    /// Descriptors of the dependencies and the rust absolute paths under which they will be available from the generated code.
    pub dependencies: Vec<(rust::Name, &'static Descriptor)>,
    /// Rust absolute path under which the protobuf crate will be available from the generated
    /// code.
    pub protobuf_crate: rust::Name,
}

/// Extracts names of proto messages defined in the descriptor.
fn extract_message_names(descriptor: &prost_types::FileDescriptorSet) -> Vec<ProtoPackage> {
    fn collect(out: &mut Vec<ProtoPackage>, m: &prost_types::DescriptorProto) {
        for m in m.child_messages() {
            collect(out,m);
        }
        out.push(m.name().into());
    }
    let mut res = vec![];
    for f in &descriptor.file {
        for m in &f.message_type {
            collect(res,m);
        }
    }
    res
}

impl Config {
    /// Proto package that all compiled proto files are supposed to belong to.
    /// It is derived from `proto_path` by simply replacing all '/' with '.'.
    fn proto_package(&self) -> ProtoPackage {
        ProtoPackage::from(&*self.proto_path)
    }

    /// Location of the protobuf_build crate, visible from the generated code.
    fn this_crate(&self) -> rust::Name {
        self.protobuf_crate.clone().add("build")
    }

    /// Generates implementation of `prost_reflect::ReflectMessage` for a rust type generated
    /// from a message of the given `proto_name`.
    fn reflect_impl(&self, proto_name: ProtoPackage) -> String {
        let rust_name = proto_name.strip_prefix(&self.proto_package()).unwrap().to_rust_type().to_string();
        let proto_name = proto_name.to_string();
        let this = self.this_crate().to_string();
        format!("impl {this}::prost_reflect::ReflectMessage for {rust_name} {{\
            fn descriptor(&self) -> {this}::prost_reflect::MessageDescriptor {{\
                static INIT : {this}::Lazy<{this}::prost_reflect::MessageDescriptor> = {this}::Lazy::new(|| {{\
                    DESCRIPTOR.load_global().get_message_by_name({proto_name:?}).unwrap()\
                }});\
                INIT.clone()\
            }}\
        }}")
    }

    /// Generates rust code from the proto files according to the config. 
    pub fn generate(&self) -> anyhow::Result<()> { 
        let input_path = self.input_path.abs();
        assert!(input_path.is_dir(),"input_path should be a directory");
        println!("cargo:rerun-if-changed={input_path:?}");
        
        // Load dependencies.
        let mut pool = prost_reflect::DescriptorPool::new();
        for d in &self.dependencies {
            d.1.load(&mut pool).with_context(||format!("failed to load dependency {}",d.0))?;
        }
        let mut pool_raw = prost_types::FileDescriptorSet::default();
        pool_raw.file = pool.file_descriptor_protos().cloned().collect();

        // Load proto files.
        let mut proto_paths = vec![];
        traverse_files(&input_path, &mut |path| {
            let Some(ext) = path.extension() else { return Ok(()) };
            let Some(ext) = ext.to_str() else { return Ok(()) };
            if ext != "proto" { return Ok(()) };

            let file_raw = fs::read_to_string(path).context("fs::read()")?;
            // Replace `input_path` with `proto_path` in path.
            let path = self.proto_path.join(path.strip_prefix(&input_path).unwrap());
            pool_raw.file.push(protox_parse::parse(path.to_str().unwrap(),&file_raw))
                .context("protox_parse::parse()")?;
            proto_paths.push(path);
            Ok(())
        })?;

        // Compile the proto files
        let mut compiler = protox::Compiler::with_file_resolver(
            protox::file::DescriptorSetFileResolver::new(pool_raw)
        );
        // TODO: nice compilation errors.
        compiler.open_files(new_paths).unwrap();
        let descriptor = compiler.file_descriptor_set();
        pool.add_file_descriptor_set(descriptor.clone()).unwrap();
       
        // Check that the compiled proto files belong to the declared proto package
        // and that proto messages support canonical encoding.
        let proto_package = self.proto_package();
        for f in &descriptor.file {
            if !ProtoPackage::from(f.package()).starts_with(&proto_package) {
                anyhow::bail!("{:?} ({:?}) does not belong to package {:?}",f.package(),f.name(),proto_package.to_string());
            }
        }

        // Check that the compiled proto messages support canonical encoding.
        canonical::check(&descriptor,&pool).context("canonical::check()")?;

        // Prepare the output directory.
        let output_dir = self.input_path.prepare_output_dir();
        let output_path = output_dir.join("gen.rs");
        let descriptor_path = output_dir.join("gen.binpb");
        fs::write(&descriptor_path, &descriptor.encode_to_vec())?;
        println!("PROTOBUF_DESCRIPTOR={descriptor_path:?}");

        // Generate code out of compiled proto files.
        let mut output = rust::Module::default();
        let mut config = prost_build::Config::new();
        config.prost_path(self.this_crate().add("prost").to_string());
        config.skip_protoc_run();
        for d in &self.dependencies {
            for f in &d.1.descriptor_proto.file {
                let proto_rel = ProtoPackage::from(f.package()).strip_prefix(&d.1.proto_package).unwrap();
                let rust_abs = rust::Name::from(d.0).add(proto_rel.to_rust_module());
                config.extern_path(format!(".{}",f.package()), rust_abs.to_string());
            }
        }
        let modules : Vec<_> = descriptor.file.iter().map(|d|(prost_build::Module::from_protobuf_package_name(d.package()),d.clone())).collect();
        for (name,code) in config.generate(modules).expect("generation failed") {
            output.insert(&name.into(),&code);
        }

        // Generate the reflection code.
        let output = output.sub(&self.proto_path.to_rust_module()); 
        for proto_name in extract_message_names(&descriptor) {
            output.append_code(&self.reflect_impl(proto_name));
        }

        // Generate the descriptor.
        let rust_deps = self.dependencies.iter().map(|d|format!("&{}::DESCRIPTOR",d.0)).collect::<Vec<_>>().join(",");
        let this = self.this_crate().to_string();
        output.append_code(&format!("\
            pub static DESCRIPTOR : {this}::Lazy<{this}::Descriptor> = {this}::Lazy::new(|| {{\
                {this}::Descriptor::new({:?}.into(), vec![{rust_deps}], &include_bytes!({descriptor_path:?}))\
            }});\
        ",proto_package.to_string()));

        // Save output.
        fs::write(&output_path, output.format())?;
        Ok(())
    }
}
