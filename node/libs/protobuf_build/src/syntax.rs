//! * input path - absolute path of the proto file as visible in the file system. Example:
//!         $CARGO_MANIFEST_DIR/<input_root>/some/location/x.proto
//! * output path - absolute path of the output files (generated by this library) as visible in the
//!     file system. Output paths are derived from the input paths by replacing $CARGO_MANIFEST_DIR with $OUT_DIR.
//!     Example:
//!         $OUT_DIR/<input_root>/generated_file
//! * proto path - absolute path of the proto file used for importing other proto files.
//!     These are derived from input path by replacing the $CARGO_MANIFEST_DIR/<input_root> with <proto_root>.
//!     Example:
//!         <proto_root>/some/location/x.proto
//! * proto name - in addition to input paths and proto paths, there are also proto names
//!     which are used to reference message types from different proto
//!     files. Theoretically proto names can be totally independent from the proto paths (i.e. you can have
//!     "my.favorite.package" proto package defined in "totally/unrelated/file/name.proto" file, but we
//!     recommend the following naming convention: proto package "a.b.c" should be defined either:
//!     a) in a single file "a/b/c.proto", or
//!     b) in a collection of files under "a/b/c/" directory
//!     Option b) is useful for defining large packages, because there is no equivalent of "pub use" in proto syntax.
//! * rust name - a rust module/type name that the generated code is available at. Although
//!     generated code is location agnostic (it can be embedded in an arbitrary module within the crate),
//!     you need to manually (in the Config) specify the rust modules containing the generated code
//!     of the dependencies, so that it can be referenced from the newly generated code. Example:
//!         <some_crate>::some::location::x
use std::collections::BTreeMap;
use anyhow::Context as _;
use super::ident;
use std::path::{Path,PathBuf};

/// Path relative to $CARGO_MANIFEST_DIR, containing the input files.
#[derive(Clone,PartialEq,Eq)]
pub struct InputPath(PathBuf);

impl From<&str> for InputPath {
    fn from(s:&str) -> Self { Self(PathBuf::from(s)) }
}

impl InputPath {
    /// Converts the relative input path to an absolute path in the local file system.
    fn abs(&self) -> PathBuf {
        PathBuf::from(std::env::var("CARGO_MANIFEST_DIR").unwrap())
            .canonicalize().unwrap().join(&self.0)
    }

    /// Derives the output path (under $OUT_DIR) from the input path
    /// and re-constructs all the parent directories.
    fn prepare_output_dir(&self) -> PathBuf {
        let output = PathBuf::from(std::env::var("OUT_DIR").unwrap())
            .canonicalize().unwrap().join(&self.0);
        let _ = fs::remove_dir_all(&output);
        fs::create_dir_all(&output).unwrap();
        output
    }
}

#[derive(Clone,PartialEq,Eq)]
pub struct ProtoPath(PathBuf);

impl From<&str> for ProtoPath {
    fn from(s:&str) -> Self { Self(PathBuf::from(s)) }
}

type Part = String;

#[derive(Clone,PartialEq,Eq)]
pub struct RustName(Vec<Part>);

impl RustName {
    pub fn add(mut self, suffix: impl Into<Self>) -> Self {
        self.0.extend(suffix.into().0.into_iter());
        self
    }

    pub fn to_string(&self) -> String { self.0.join("::") }
}

impl From<prost_build::Module> for RustName {
    fn from(s:prost_build::Module) -> Self { Self(s.parts().map(Part::from).collect()) }
}

impl From<&str> for RustName {
    fn from(s:&str) -> Self { Self(s.split("::").map(Part::from).collect()) }
}

/// A rust module representation.
/// It is used to collect the generated protobuf code.
#[derive(Default)]
pub(super) struct Module {
    /// Nested modules which transitively contain the generated code.
    modules: BTreeMap<Part, Module>,
    /// Code of the module.
    code: String,
}

impl Module {
    pub fn sub(&mut self, path: &RustName) -> &mut Self {
        let mut m = self;
        for part in &path.0 {
            m = m.modules.entry(part.into()).or_default();
        }
        m
    }

    /// Appends code to the module.
    pub fn append(&mut self, code: &str) {
        self.code += code;
    }

    fn collect(&self) -> String {
        let mut entries = vec![self.code.clone()];
        entries.extend(
            self.modules.iter().map(|(name, m)| format!("pub mod {name} {{ {} }}\n", m.collect())),
        );
        entries.join("")
    }

    /// Collects the code of the module.
    pub fn format(&self) -> anyhow::Result<String> {
        Ok(prettyplease::unparse(&syn::parse_str(&self.collect()).context("syn::parse_str()")?))
    }
}


/// Represents a (relative) proto package path.
#[derive(Clone,PartialEq,Eq)]
pub(super) struct ProtoName(Vec<String>);

impl ProtoName {
    /// Checks if package path starts with the given prefix.
    pub fn starts_with(&self, prefix: &Self) -> bool {
        let n = prefix.0.len();
        self.0.len() >= n && self.0[0..n] == prefix.0
    }

    pub fn strip_prefix(&self, prefix: &Self) -> anyhow::Result<Self> {
        if !self.starts_with(prefix) {
            anyhow::bail!("{} is not a prefix of {}",prefix.to_string(),self.to_string());
        }
        Ok(Self(self.0[prefix.0.len()..].iter().cloned().collect()))
    }

    pub fn to_rust_module(&self) -> rust::Name {
        rust::Name::from_parts(self.0.iter().map(|s|ident::to_snake(s)).collect())
    }

    pub fn to_rust_type(&self) -> rust::Name {
        let mut parts : Vec<_> = self.0.iter().map(|s|ident::to_snake(s)).collect();
        let n = parts.len();
        parts[n-1] = ident::to_upper_camel(&self.0[n-1]);
        rust::Name::from_parts(parts)
    }

    pub fn to_string(&self) -> String {
        self.0.join(".")
    }
}

impl From<&str> for ProtoName {
    fn from(s:&str) -> Self {
        Self(s.split(".").map(String::from).collect())
    }
}

impl From<&Path> for ProtoName {
    fn from(p:&Path) -> Self {
        Self(p.iter().map(|c|c.to_str().unwrap().to_string()).collect())
    }
}


/// Extracts names of proto messages defined in the descriptor.
pub(super) fn extract_message_names(descriptor: &prost_types::FileDescriptorSet) -> Vec<ProtoName> {
    fn collect(out: &mut Vec<ProtoName>, m: &prost_types::DescriptorProto) {
        for m in &m.nested_type {
            collect(out,m);
        }
        out.push(m.name().into());
    }
    let mut res = vec![];
    for f in &descriptor.file {
        for m in &f.message_type {
            collect(&mut res,m);
        }
    }
    res
}
